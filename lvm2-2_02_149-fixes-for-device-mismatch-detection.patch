 WHATS_NEW                       |   6 ++
 lib/device/dev-cache.c          | 212 ++++++++++++++++++++++++++++++++--------
 lib/device/dev-cache.h          |   1 +
 lib/filters/filter-persistent.c |   2 +
 lib/metadata/metadata.c         |  15 ++-
 5 files changed, 191 insertions(+), 45 deletions(-)

diff --git a/WHATS_NEW b/WHATS_NEW
index 7c636b8..8438d5e 100644
--- a/WHATS_NEW
+++ b/WHATS_NEW
@@ -1,3 +1,9 @@
+Version 2.02.149 - 
+==================================
+  Remove spurious error about no value in /sys/dev/block/major:minor/dm/uuid.
+  Fix device mismatch detection for LV if persistent .cache file is used.
+  Fix holder device not being found in /dev while sysfs has it during dev scan.
+
 Version 2.02.148 - 
 =====================================
   Detect and warn about mismatch between devices used and assumed for an LV.
diff --git a/lib/device/dev-cache.c b/lib/device/dev-cache.c
index 237ef87..5c76c35 100644
--- a/lib/device/dev-cache.c
+++ b/lib/device/dev-cache.c
@@ -42,6 +42,7 @@ static struct {
 	struct dm_hash_table *names;
 	struct dm_hash_table *vgid_index;
 	struct dm_hash_table *lvid_index;
+	struct btree *sysfs_only_devices; /* see comments in _get_device_for_sysfs_dev_name_using_devno */
 	struct btree *devices;
 	struct dm_regex *preferred_names_matcher;
 	const char *dev_dir;
@@ -362,10 +363,11 @@ static int _add_alias(struct device *dev, const char *path)
 	return 1;
 }
 
-static int _get_sysfs_value(const char *path, char *buf, size_t buf_size)
+static int _get_sysfs_value(const char *path, char *buf, size_t buf_size, int error_if_no_value)
 {
 	FILE *fp;
 	size_t len;
+	int r = 0;
 
 	if (!(fp = fopen(path, "r"))) {
 		log_sys_error("fopen", path);
@@ -374,23 +376,25 @@ static int _get_sysfs_value(const char *path, char *buf, size_t buf_size)
 
 	if (!fgets(buf, buf_size, fp)) {
 		log_sys_error("fgets", path);
-		if (fclose(fp))
-			log_sys_error("fclose", path);
-		return 0;
+		goto out;
 	}
 
 	if (!(len = strlen(buf)) || (len == 1 && buf[0] == '\n')) {
-		log_error("_get_sysfs_value: %s: no value", path);
-		return 0;
+		if (error_if_no_value) {
+			log_error("_get_sysfs_value: %s: no value", path);
+			goto out;
+		}
 	}
 
 	if (buf[len - 1] == '\n')
 		buf[len - 1] = '\0';
 
+	r = 1;
+out:
 	if (fclose(fp))
 		log_sys_error("fclose", path);
 
-	return 1;
+	return r;
 }
 
 static int _get_dm_uuid_from_sysfs(char *buf, size_t buf_size, int major, int minor)
@@ -402,7 +406,7 @@ static int _get_dm_uuid_from_sysfs(char *buf, size_t buf_size, int major, int mi
 		return 0;
 	}
 
-	return _get_sysfs_value(path, buf, buf_size);
+	return _get_sysfs_value(path, buf, buf_size, 0);
 }
 
 static struct dm_list *_get_or_add_list_by_index_key(struct dm_hash_table *idx, const char *key)
@@ -427,26 +431,80 @@ static struct dm_list *_get_or_add_list_by_index_key(struct dm_hash_table *idx,
 	return list;
 }
 
-static struct device *_get_device_for_sysfs_dev_name_using_devno(const char *dev_name)
+static struct device *_insert_sysfs_dev(dev_t devno, const char *devname)
+{
+	char path[PATH_MAX];
+	char *path_copy;
+	struct device *dev;
+
+	if (dm_snprintf(path, sizeof(path), "%s%s", _cache.dev_dir, devname) < 0) {
+		log_error("_insert_sysfs_dev: %s: dm_snprintf failed", devname);
+		return NULL;
+	}
+
+	if (!(dev = _dev_create(devno)))
+		return_NULL;
+
+	if (!(path_copy = dm_pool_strdup(_cache.mem, path))) {
+		log_error("_insert_sysfs_dev: %s: dm_pool_strdup failed", devname);
+		return NULL;
+	}
+
+	if (!_add_alias(dev, path_copy)) {
+		log_error("Couldn't add alias to dev cache.");
+		_free(dev);
+		return NULL;
+	}
+
+	if (!btree_insert(_cache.sysfs_only_devices, (uint32_t) devno, dev)) {
+		log_error("Couldn't add device to binary tree of sysfs-only devices in dev cache.");
+		_free(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+
+static struct device *_get_device_for_sysfs_dev_name_using_devno(const char *devname)
 {
 	char path[PATH_MAX];
 	char buf[PATH_MAX];
 	int major, minor;
+	dev_t devno;
+	struct device *dev;
 
-	if (dm_snprintf(path, sizeof(path), "%sblock/%s/dev", dm_sysfs_dir(), dev_name) < 0) {
-		log_error("_get_device_for_non_dm_dev: %s: dm_snprintf failed", dev_name);
+	if (dm_snprintf(path, sizeof(path), "%sblock/%s/dev", dm_sysfs_dir(), devname) < 0) {
+		log_error("_get_device_for_sysfs_dev_name_using_devno: %s: dm_snprintf failed", devname);
 		return NULL;
 	}
 
-	if (!_get_sysfs_value(path, buf, sizeof(buf)))
+	if (!_get_sysfs_value(path, buf, sizeof(buf), 1))
 		return_NULL;
 
 	if (sscanf(buf, "%d:%d", &major, &minor) != 2) {
-		log_error("_get_device_for_non_dm_dev: %s: failed to get major and minor number", dev_name);
+		log_error("_get_device_for_sysfs_dev_name_using_devno: %s: failed to get major and minor number", devname);
 		return NULL;
 	}
 
-	return (struct device *) btree_lookup(_cache.devices, (uint32_t) MKDEV(major, minor));
+	devno = MKDEV(major, minor);
+	if (!(dev = (struct device *) btree_lookup(_cache.devices, (uint32_t) devno))) {
+		/*
+		 * If we get here, it means the device is referenced in sysfs, but it's not yet in /dev.
+		 * This may happen in some rare cases right after LVs get created - we sync with udev
+		 * (or alternatively we create /dev content ourselves) while VG lock is held. However,
+		 * dev scan is done without VG lock so devices may already be in sysfs, but /dev may
+		 * not be updated yet if we call LVM command right after LV creation. This is not a
+		 * problem with devtmpfs as there's at least kernel name for device in /dev as soon
+		 * as the sysfs item exists, but we still support environments without devtmpfs or
+		 * where different directory for dev nodes is used (e.g. our test suite). So track
+		 * such devices in _cache.sysfs_only_devices hash for the vgid/lvid check to work still.
+		 */
+		if (!(dev = (struct device *) btree_lookup(_cache.sysfs_only_devices, (uint32_t) devno)) &&
+		    !(dev = _insert_sysfs_dev(devno, devname)))
+			return_NULL;
+	}
+
+	return dev;
 }
 
 #define NOT_LVM_UUID "-"
@@ -493,6 +551,9 @@ static int _index_dev_by_vgid_and_lvid(struct device *dev)
 	struct device_list *dl_vgid, *dl_lvid;
 	int r = 0;
 
+	if (dev->flags & DEV_USED_FOR_LV)
+		return 1;
+
 	/* Get holders for device. */
 	if (dm_snprintf(path, sizeof(path), "%sdev/block/%d:%d/holders/", dm_sysfs_dir(), (int) MAJOR(dev->dev), (int) MINOR(dev->dev)) < 0) {
 		log_error("%s: dm_snprintf failed for path to holders directory.", devname);
@@ -622,14 +683,15 @@ static int _insert_dev(const char *path, dev_t d)
 	}
 
 	/* is this device already registered ? */
-	if (!(dev = (struct device *) btree_lookup(_cache.devices,
-						   (uint32_t) d))) {
-		/* create new device */
-		if (loopfile) {
-			if (!(dev = dev_create_file(path, NULL, NULL, 0)))
+	if (!(dev = (struct device *) btree_lookup(_cache.devices, (uint32_t) d))) {
+		if (!(dev = (struct device *) btree_lookup(_cache.sysfs_only_devices, (uint32_t) d))) {
+			/* create new device */
+			if (loopfile) {
+				if (!(dev = dev_create_file(path, NULL, NULL, 0)))
+					return_0;
+			} else if (!(dev = _dev_create(d)))
 				return_0;
-		} else if (!(dev = _dev_create(d)))
-			return_0;
+		}
 
 		if (!(btree_insert(_cache.devices, (uint32_t) d, dev))) {
 			log_error("Couldn't insert device into binary tree.");
@@ -737,6 +799,89 @@ static int _insert_file(const char *path)
 	return 1;
 }
 
+static int _dev_cache_iterate_devs_for_index(void)
+{
+	struct btree_iter *iter = btree_first(_cache.devices);
+	struct device *dev;
+	int r = 1;
+
+	while (iter) {
+		dev = btree_get_data(iter);
+
+		if (!_index_dev_by_vgid_and_lvid(dev))
+			r = 0;
+
+		iter = btree_next(iter);
+	}
+
+	return r;
+}
+
+static int _dev_cache_iterate_sysfs_for_index(void)
+{
+	char path[PATH_MAX];
+	char devname[PATH_MAX];
+	DIR *d;
+	struct dirent *dirent;
+	int major, minor;
+	dev_t devno;
+	struct device *dev;
+	int partial_failure = 0;
+	int r = 0;
+
+	if (dm_snprintf(path, sizeof(path), "%sdev/block", dm_sysfs_dir()) < 0) {
+		log_error("_dev_cache_iterate_sysfs_for_index: dm_snprintf failed.");
+		return 0;
+	}
+
+	if (!(d = opendir(path))) {
+		log_sys_error("opendir", path);
+		return 0;
+	}
+
+	while ((dirent = readdir(d))) {
+		if (!strcmp(".", dirent->d_name) ||
+		    !strcmp("..", dirent->d_name))
+			continue;
+
+		if (sscanf(dirent->d_name, "%d:%d", &major, &minor) != 2) {
+			log_error("_dev_cache_iterate_sysfs_for_index: %s: failed "
+				  "to get major and minor number", dirent->d_name);
+			partial_failure = 1;
+			continue;
+		}
+
+		devno = MKDEV(major, minor);
+		if (!(dev = (struct device *) btree_lookup(_cache.devices, (uint32_t) devno)) &&
+		    !(dev = (struct device *) btree_lookup(_cache.sysfs_only_devices, (uint32_t) devno))) {
+			if (!dm_device_get_name(major, minor, 1, devname, sizeof(devname)) ||
+			    !(dev = _insert_sysfs_dev(devno, devname))) {
+				partial_failure = 1;
+				continue;
+			}
+		}
+
+		if (!_index_dev_by_vgid_and_lvid(dev))
+			partial_failure = 1;
+	}
+
+	r = !partial_failure;
+
+	if (closedir(d))
+		log_sys_error("closedir", path);
+
+	return r;
+}
+
+int dev_cache_index_devs(void)
+{
+	int with_udev = obtain_device_list_from_udev() &&
+			udev_get_library_context();
+
+	return with_udev ? _dev_cache_iterate_devs_for_index()
+			 : _dev_cache_iterate_sysfs_for_index();
+}
+
 #ifdef UDEV_SYNC_SUPPORT
 
 static int _device_in_udev_db(const dev_t d)
@@ -814,24 +959,6 @@ bad:
 	return 0;
 }
 
-static int _add_devs_to_index(void)
-{
-	struct btree_iter *iter = btree_first(_cache.devices);
-	struct device *dev;
-	int r = 1;
-
-	while (iter) {
-		dev = btree_get_data(iter);
-
-		if (!_index_dev_by_vgid_and_lvid(dev))
-			r = 0;
-
-		iter = btree_next(iter);
-	}
-
-	return r;
-}
-
 static void _insert_dirs(struct dm_list *dirs)
 {
 	struct dir_list *dl;
@@ -853,7 +980,7 @@ static void _insert_dirs(struct dm_list *dirs)
 				       "device cache fully", dl->dir);
 	}
 
-	(void) _add_devs_to_index();
+	(void) dev_cache_index_devs();
 }
 
 #else	/* UDEV_SYNC_SUPPORT */
@@ -1028,6 +1155,11 @@ int dev_cache_init(struct cmd_context *cmd)
 		goto bad;
 	}
 
+	if (!(_cache.sysfs_only_devices = btree_create(_cache.mem))) {
+		log_error("Couldn't create binary tree for sysfs-only devices in dev cache.");
+		goto bad;
+	}
+
 	if (!(_cache.dev_dir = _strdup(cmd->dev_dir))) {
 		log_error("strdup dev_dir failed.");
 		goto bad;
diff --git a/lib/device/dev-cache.h b/lib/device/dev-cache.h
index d21f521..0406970 100644
--- a/lib/device/dev-cache.h
+++ b/lib/device/dev-cache.h
@@ -31,6 +31,7 @@ struct dev_filter {
 	unsigned use_count;
 };
 
+int dev_cache_index_devs(void);
 struct dm_list *dev_cache_get_dev_list_for_vgid(const char *vgid);
 struct dm_list *dev_cache_get_dev_list_for_lvid(const char *lvid);
 
diff --git a/lib/filters/filter-persistent.c b/lib/filters/filter-persistent.c
index ed7956c..4e8161e 100644
--- a/lib/filters/filter-persistent.c
+++ b/lib/filters/filter-persistent.c
@@ -129,6 +129,8 @@ int persistent_filter_load(struct dev_filter *f, struct dm_config_tree **cft_out
 	if (dm_hash_get_num_entries(pf->devices)) {
 		/* We populated dev_cache ourselves */
 		dev_cache_scan(0);
+		if (!dev_cache_index_devs())
+			stack;
 		r = 1;
 	}
 
diff --git a/lib/metadata/metadata.c b/lib/metadata/metadata.c
index d8a97b4..e255f00 100644
--- a/lib/metadata/metadata.c
+++ b/lib/metadata/metadata.c
@@ -4322,8 +4322,10 @@ static int _check_devs_used_correspond_with_lv(struct dm_pool *mem, struct dm_li
 			if (!found_inconsistent) {
 				dm_pool_begin_object(mem, 32);
 				found_inconsistent = 1;
-			} else
-				dm_pool_grow_object(mem, DEV_LIST_DELIM, sizeof(DEV_LIST_DELIM) - 1);
+			} else {
+				if (!dm_pool_grow_object(mem, DEV_LIST_DELIM, sizeof(DEV_LIST_DELIM) - 1))
+					goto_bad;
+			}
 			if (!dm_pool_grow_object(mem, dev_name(dev), 0))
 				goto_bad;
 		}
@@ -4332,7 +4334,8 @@ static int _check_devs_used_correspond_with_lv(struct dm_pool *mem, struct dm_li
 	if (!found_inconsistent)
 		return 1;
 
-	dm_pool_grow_object(mem, "\0", 1);
+	if (!dm_pool_grow_object(mem, "\0", 1))
+		goto_bad;
 	used_devnames = dm_pool_end_object(mem);
 
 	found_inconsistent = 0;
@@ -4350,7 +4353,8 @@ static int _check_devs_used_correspond_with_lv(struct dm_pool *mem, struct dm_li
 						dm_pool_begin_object(mem, 32);
 						found_inconsistent = 1;
 					} else {
-						dm_pool_grow_object(mem, DEV_LIST_DELIM, sizeof(DEV_LIST_DELIM) - 1);
+						if (!dm_pool_grow_object(mem, DEV_LIST_DELIM, sizeof(DEV_LIST_DELIM) - 1))
+							goto_bad;
 					}
 					if (!dm_pool_grow_object(mem, dev_name(dev), 0))
 						goto bad;
@@ -4360,7 +4364,8 @@ static int _check_devs_used_correspond_with_lv(struct dm_pool *mem, struct dm_li
 	}
 
 	if (found_inconsistent) {
-		dm_pool_grow_object(mem, "\0", 1);
+		if (!dm_pool_grow_object(mem, "\0", 1))
+			goto_bad;
 		assumed_devnames = dm_pool_end_object(mem);
 	}
 
