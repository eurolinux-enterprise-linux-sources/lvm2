 WHATS_NEW                                         |  7 +++
 WHATS_NEW_DM                                      |  5 ++
 daemons/clvmd/clvm.h                              |  2 +-
 daemons/cmirrord/cluster.c                        |  2 +-
 daemons/dmeventd/plugins/mirror/dmeventd_mirror.c |  1 -
 daemons/lvmlockd/lvmlockd-core.c                  |  2 +-
 lib/activate/dev_manager.c                        | 13 +++--
 lib/cache/lvmetad.c                               | 58 +++++++++++--------
 lib/device/dev-md.c                               |  4 +-
 lib/device/dev-type.h                             |  6 +-
 lib/format_text/archiver.c                        |  2 +-
 lib/log/log.c                                     |  2 +-
 lib/metadata/lv_manip.c                           | 12 ++--
 lib/metadata/metadata.c                           |  6 +-
 lib/metadata/pv_manip.c                           | 68 +++++++++++------------
 lib/metadata/raid_manip.c                         |  2 +-
 lib/metadata/thin_manip.c                         |  4 +-
 lib/misc/sharedlib.c                              |  5 +-
 lib/raid/raid.c                                   |  2 +-
 lib/report/report.c                               |  3 +-
 libdaemon/client/daemon-io.c                      | 10 ++--
 libdm/libdm-report.c                              | 13 +++--
 libdm/libdm-stats.c                               | 22 ++++----
 libdm/mm/pool-fast.c                              |  6 +-
 test/lib/aux.sh                                   | 12 ++++
 test/shell/pvremove-usage.sh                      |  9 ++-
 test/shell/thin-flags.sh                          |  1 +
 tools/dmsetup.c                                   |  2 +-
 tools/lvchange.c                                  |  2 +-
 tools/lvconvert.c                                 |  2 +-
 tools/lvrename.c                                  |  4 +-
 tools/lvresize.c                                  |  6 +-
 tools/vgrename.c                                  |  3 +-
 33 files changed, 174 insertions(+), 124 deletions(-)

diff --git a/WHATS_NEW b/WHATS_NEW
index 9097ce9..378150c 100644
--- a/WHATS_NEW
+++ b/WHATS_NEW
@@ -1,3 +1,10 @@
+Version 2.02.144 - 
+=====================================
+  Always warn user about PV in use even when pvremove uses --force --force.
+  Use uninitilized pool header detection in all cases.
+  Fir read error detection when checking for uninitialized thin-pool header.
+  Fix error path for internal error in lvmetad vg lookup code.
+
 Version 2.02.143 - 21st February 2016
 =====================================
   Fix error path when sending thin-pool message fails in update_pool_lv().
diff --git a/WHATS_NEW_DM b/WHATS_NEW_DM
index f23c541..14793b3 100644
--- a/WHATS_NEW_DM
+++ b/WHATS_NEW_DM
@@ -1,3 +1,8 @@
+Version 1.02.118 -
+=====================================
+  Fix string boundary check in _get_canonical_field_name().
+  Always initialized hist struct in _stats_parse_histogram().
+
 Version 1.02.117 - 21st February 2016
 =====================================
   Improve status parsing for thin-pool and thin devices.
diff --git a/daemons/clvmd/clvm.h b/daemons/clvmd/clvm.h
index 75cc296..ae0a13a 100644
--- a/daemons/clvmd/clvm.h
+++ b/daemons/clvmd/clvm.h
@@ -50,7 +50,7 @@ struct clvm_header {
 #define CLVMD_FLAG_REMOTE	8	/* Do this on all nodes except for the local node */
 
 /* Name of the local socket to communicate between lvm and clvmd */
-static const char CLVMD_SOCKNAME[]= DEFAULT_RUN_DIR "/clvmd.sock";
+#define CLVMD_SOCKNAME		DEFAULT_RUN_DIR "/clvmd.sock"
 
 /* Internal commands & replies */
 #define CLVMD_CMD_REPLY    1
diff --git a/daemons/cmirrord/cluster.c b/daemons/cmirrord/cluster.c
index 3b8fef3..e196eb2 100644
--- a/daemons/cmirrord/cluster.c
+++ b/daemons/cmirrord/cluster.c
@@ -1440,7 +1440,7 @@ static void cpg_leave_callback(struct clog_cpg *match,
 			free(rq);
 		}
 	}
-	for (i = 0, j = 0; i < match->checkpoints_needed; i++, j++) {
+	for (i = 0, j = 0; (int) i < match->checkpoints_needed; i++, j++) {
 		match->checkpoint_requesters[j] = match->checkpoint_requesters[i];
 		if (match->checkpoint_requesters[i] == left->nodeid) {
 			LOG_ERROR("[%s] Removing pending ckpt from needed list (%u is leaving)",
diff --git a/daemons/dmeventd/plugins/mirror/dmeventd_mirror.c b/daemons/dmeventd/plugins/mirror/dmeventd_mirror.c
index ba4044f..25d1063 100644
--- a/daemons/dmeventd/plugins/mirror/dmeventd_mirror.c
+++ b/daemons/dmeventd/plugins/mirror/dmeventd_mirror.c
@@ -15,7 +15,6 @@
 #include "lib.h"
 #include "libdevmapper-event.h"
 #include "dmeventd_lvm.h"
-#include "defaults.h"
 
 /* FIXME Reformat to 80 char lines. */
 
diff --git a/daemons/lvmlockd/lvmlockd-core.c b/daemons/lvmlockd/lvmlockd-core.c
index 292d19c..219b120 100644
--- a/daemons/lvmlockd/lvmlockd-core.c
+++ b/daemons/lvmlockd/lvmlockd-core.c
@@ -317,7 +317,7 @@ static void log_save_line(int len, char *line,
 	unsigned int w = *wrap;
 	int i;
 
-	if (len < LOG_DUMP_SIZE - p) {
+	if (len < (int) (LOG_DUMP_SIZE - p)) {
 		memcpy(log_buf + p, line, len);
 		p += len;
 
diff --git a/lib/activate/dev_manager.c b/lib/activate/dev_manager.c
index 2826218..2d59cf4 100644
--- a/lib/activate/dev_manager.c
+++ b/lib/activate/dev_manager.c
@@ -316,7 +316,7 @@ static int _ignore_blocked_mirror_devices(struct device *dev,
 			if (!(tmp_dev = dev_create_file(buf, NULL, NULL, 0)))
 				goto_out;
 
-			tmp_dev->dev = MKDEV((dev_t)sm->logs[0].major, sm->logs[0].minor);
+			tmp_dev->dev = MKDEV((dev_t)sm->logs[0].major, (dev_t)sm->logs[0].minor);
 			if (device_is_usable(tmp_dev, (struct dev_usable_check_params)
 					     { .check_empty = 1,
 					       .check_blocked = 1,
@@ -352,7 +352,8 @@ static int _ignore_blocked_mirror_devices(struct device *dev,
 	do {
 		next = dm_get_next_target(dmt, next, &s, &l,
 					  &target_type, &params);
-		if ((s == start) && (l == length)) {
+		if ((s == start) && (l == length) &&
+		    target_type && params) {
 			if (strcmp(target_type, "mirror"))
 				goto_out;
 
@@ -1841,20 +1842,20 @@ static int _pool_callback(struct dm_tree_node *node,
 			return 0;
 		}
 		/* let's assume there is no problem to read 64 bytes */
-		if (read(fd, buf, sizeof(buf)) < sizeof(buf)) {
+		if (read(fd, buf, sizeof(buf)) < (int)sizeof(buf)) {
 			log_sys_error("read", argv[args]);
 			if (close(fd))
 				log_sys_error("close", argv[args]);
 			return 0;
 		}
-		for (ret = 0; ret < DM_ARRAY_SIZE(buf); ++ret)
+		for (ret = 0; ret < (int) DM_ARRAY_SIZE(buf); ++ret)
 			if (buf[ret])
 				break;
 
 		if (close(fd))
 			log_sys_error("close", argv[args]);
 
-		if (ret == DM_ARRAY_SIZE(buf)) {
+		if (ret == (int) DM_ARRAY_SIZE(buf)) {
 			log_debug("%s skipped, detect empty disk header on %s.",
 				  argv[0], argv[args]);
 			return 1;
@@ -1916,7 +1917,7 @@ static int _pool_register_callback(struct dev_manager *dm,
 		data->global = "thin";
 	} else if (lv_is_cache(lv)) { /* cache pool */
 		data->pool_lv = first_seg(lv)->pool_lv;
-		data->skip_zero = dm->activation;
+		data->skip_zero = 1; /* cheap read-error detection */
 		data->exec = global_cache_check_executable_CFG;
 		data->opts = global_cache_check_options_CFG;
 		data->global = "cache";
diff --git a/lib/cache/lvmetad.c b/lib/cache/lvmetad.c
index 7d6356d..a483e04 100644
--- a/lib/cache/lvmetad.c
+++ b/lib/cache/lvmetad.c
@@ -105,6 +105,7 @@ void lvmetad_disconnect(void)
 {
 	if (_lvmetad_connected)
 		daemon_close(_lvmetad);
+
 	_lvmetad_connected = 0;
 }
 
@@ -165,14 +166,17 @@ int lvmetad_socket_present(void)
 int lvmetad_active(void)
 {
 	lvmetad_connect_or_warn();
+
 	return _lvmetad_connected;
 }
 
 void lvmetad_set_active(struct cmd_context *cmd, int active)
 {
 	_lvmetad_use = active;
+
 	if (!active && lvmetad_active())
 		lvmetad_disconnect();
+
 	if (cmd && !refresh_filters(cmd))
 		stack;
 }
@@ -282,6 +286,7 @@ static int _token_update(void)
 	}
 
 	daemon_reply_destroy(repl);
+
 	return 1;
 }
 
@@ -490,6 +495,7 @@ static int _pv_populate_lvmcache(struct cmd_context *cmd,
 static int _pv_update_struct_pv(struct physical_volume *pv, struct format_instance *fid)
 {
 	struct lvmcache_info *info;
+
 	if ((info = lvmcache_info_from_pvid((const char *)&pv->id, 0))) {
 		pv->label_sector = lvmcache_get_label(info)->sector;
 		pv->dev = lvmcache_device(info);
@@ -497,9 +503,10 @@ static int _pv_update_struct_pv(struct physical_volume *pv, struct format_instan
 			pv->status |= MISSING_PV;
 		if (!lvmcache_fid_add_mdas_pv(info, fid))
 			return_0;
-                pv->fid = fid;
+		pv->fid = fid;
 	} else
 		pv->status |= MISSING_PV; /* probably missing */
+
 	return 1;
 }
 
@@ -507,7 +514,7 @@ struct volume_group *lvmetad_vg_lookup(struct cmd_context *cmd, const char *vgna
 {
 	struct volume_group *vg = NULL;
 	struct volume_group *vg2 = NULL;
-	daemon_reply reply;
+	daemon_reply reply = { 0 };
 	int found;
 	char uuid[64];
 	struct format_instance *fid = NULL;
@@ -680,9 +687,12 @@ struct _fixup_baton {
 
 static int _fixup_ignored(struct metadata_area *mda, void *baton) {
 	struct _fixup_baton *b = baton;
+
 	if (b->i == b->find)
 		mda_set_ignored(mda, b->ignore);
+
 	b->i ++;
+
 	return 1;
 }
 
@@ -829,6 +839,7 @@ out_success:
 
 out:
 	daemon_reply_destroy(reply);
+
 	return result;
 }
 
@@ -903,6 +914,7 @@ int lvmetad_get_vgnameids(struct cmd_context *cmd, struct dm_list *vgnameids)
 	}
 
 	daemon_reply_destroy(reply);
+
 	return 1;
 }
 
@@ -938,6 +950,7 @@ int lvmetad_vg_list_to_lvmcache(struct cmd_context *cmd)
 		}
 
 	daemon_reply_destroy(reply);
+
 	return 1;
 }
 
@@ -1005,13 +1018,15 @@ static int _extract_ba(struct disk_locn *ba, void *baton)
 static int _extract_mdas(struct lvmcache_info *info, struct dm_config_tree *cft,
 			 struct dm_config_node *pre_sib)
 {
-	struct _extract_dl_baton baton = { .i = 0, .cft = cft, .pre_sib = NULL };
+	struct _extract_dl_baton baton = { .cft = cft };
 
 	if (!lvmcache_foreach_mda(info, &_extract_mda, &baton))
 		return 0;
+
 	baton.i = 0;
 	if (!lvmcache_foreach_da(info, &_extract_da, &baton))
 		return 0;
+
 	baton.i = 0;
 	if (!lvmcache_foreach_ba(info, &_extract_ba, &baton))
 		return 0;
@@ -1047,14 +1062,16 @@ int lvmetad_pv_found(const struct id *pvid, struct device *dev, const struct for
 		return_0;
 	}
 
+	/* TODO: resolve what does it actually mean  'info == NULL'
+	 *       missing info is likely an INTERNAL_ERROR */
 	if (!config_make_nodes(pvmeta, pvmeta->root, NULL,
 			       "device = %"PRId64, (int64_t) dev->dev,
 			       "dev_size = %"PRId64, (int64_t) (info ? lvmcache_device_size(info) : 0),
 			       "format = %s", fmt->name,
 			       "label_sector = %"PRId64, (int64_t) label_sector,
 			       "id = %s", uuid,
-			       "ext_version = %"PRId64, (int64_t) lvmcache_ext_version(info),
-			       "ext_flags = %"PRId64, (int64_t) lvmcache_ext_flags(info),
+			       "ext_version = %"PRId64, (int64_t) (info ? lvmcache_ext_version(info) : 0),
+			       "ext_flags = %"PRId64, (int64_t) (info ? lvmcache_ext_flags(info) : 0),
 			       NULL))
 	{
 		dm_config_destroy(pvmeta);
@@ -1172,11 +1189,11 @@ int lvmetad_pv_gone(dev_t devno, const char *pv_name, activation_handler handler
 		return 1;
 
 	/*
-         *  TODO: automatic volume deactivation takes place here *before*
-         *        all cached info is gone - call handler. Also, consider
-         *        integrating existing deactivation script  that deactivates
-         *        the whole stack from top to bottom (not yet upstream).
-         */
+	 *  TODO: automatic volume deactivation takes place here *before*
+	 *        all cached info is gone - call handler. Also, consider
+	 *        integrating existing deactivation script  that deactivates
+	 *        the whole stack from top to bottom (not yet upstream).
+	 */
 
 	log_debug_lvmetad("Telling lvmetad to forget any PV on %s", pv_name);
 	reply = _lvmetad_send("pv_gone", "device = %" PRId64, (int64_t) devno, NULL);
@@ -1415,8 +1432,9 @@ int lvmetad_pvscan_single(struct cmd_context *cmd, struct device *dev,
 
 bad:
 	/* FIXME kill lvmetad automatically if we can */
-	log_error("Update of lvmetad failed. This is a serious problem.\n  "
+	log_error("Update of lvmetad failed. This is a serious problem.\n"
 		  "It is strongly recommended that you restart lvmetad immediately.");
+
 	return 0;
 }
 
@@ -1536,6 +1554,7 @@ static int _lvmetad_get_pv_cache_list(struct cmd_context *cmd, struct dm_list *p
 		return 1;
 
 	log_debug_lvmetad("Asking lvmetad for complete list of known PVs");
+
 	reply = _lvmetad_send("pv_list", NULL);
 	if (!_lvmetad_handle_reply(reply, "list PVs", "", NULL)) {
 		log_error("lvmetad message failed.");
@@ -1632,10 +1651,8 @@ static void _update_changed_pvs_in_udev(struct cmd_context *cmd,
 				continue;
 
 			if (!id_equal(&before->pvid, &after->pvid)) {
-				memset(id_before, 0, sizeof(id_before));
-				memset(id_after, 0, sizeof(id_after));
-				strncpy(&id_before[0], (char *) &before->pvid, sizeof(id_before) - 1);
-				strncpy(&id_after[0], (char *) &after->pvid, sizeof(id_after) - 1);
+				dm_strncpy(id_before, (char *) &before->pvid, sizeof(id_before));
+				dm_strncpy(id_after, (char *) &after->pvid, sizeof(id_after));
 
 				log_debug_devs("device %d:%d changed pvid from %s to %s",
 					       (int)MAJOR(before->devt), (int)MINOR(before->devt),
@@ -1661,8 +1678,7 @@ static void _update_changed_pvs_in_udev(struct cmd_context *cmd,
 		}
 
 		if (!found) {
-			memset(id_before, 0, sizeof(id_before));
-			strncpy(&id_before[0], (char *) &before->pvid, sizeof(id_before) - 1);
+			dm_strncpy(id_before, (char *) &before->pvid, sizeof(id_before));
 
 			log_debug_devs("device %d:%d pvid %s vg %s is gone",
 				       (int)MAJOR(before->devt), (int)MINOR(before->devt),
@@ -1754,10 +1770,8 @@ void lvmetad_validate_global_cache(struct cmd_context *cmd, int force)
 
 	daemon_reply_destroy(reply);
 
-	if (!global_invalid) {
-		/* cache is valid */
-		return;
-	}
+	if (!global_invalid)
+		return; /* cache is valid */
 
  do_scan:
 	/*
@@ -1839,6 +1853,6 @@ int lvmetad_vg_is_foreign(struct cmd_context *cmd, const char *vgname, const cha
 	ret = !is_system_id_allowed(cmd, system_id);
 
 	daemon_reply_destroy(reply);
+
 	return ret;
 }
-
diff --git a/lib/device/dev-md.c b/lib/device/dev-md.c
index b6ee59f..3dbe831 100644
--- a/lib/device/dev-md.c
+++ b/lib/device/dev-md.c
@@ -38,8 +38,8 @@ static int _dev_has_md_magic(struct device *dev, uint64_t sb_offset)
 
 	/* Version 1 is little endian; version 0.90.0 is machine endian */
 	if (dev_read(dev, sb_offset, sizeof(uint32_t), &md_magic) &&
-	    ((md_magic == xlate32(MD_SB_MAGIC)) ||
-	     (md_magic == MD_SB_MAGIC)))
+	    ((md_magic == MD_SB_MAGIC) ||
+	     ((MD_SB_MAGIC != xlate32(MD_SB_MAGIC)) && (md_magic == xlate32(MD_SB_MAGIC)))))
 		return 1;
 
 	return 0;
diff --git a/lib/device/dev-type.h b/lib/device/dev-type.h
index 75ef36f..5494511 100644
--- a/lib/device/dev-type.h
+++ b/lib/device/dev-type.h
@@ -21,9 +21,9 @@
 #define NUMBER_OF_MAJORS 4096
 
 #ifdef __linux__
-#  define MAJOR(dev)	((dev & 0xfff00) >> 8)
-#  define MINOR(dev)	((dev & 0xff) | ((dev >> 12) & 0xfff00))
-#  define MKDEV(ma,mi)	((mi & 0xff) | (ma << 8) | ((mi & ~0xff) << 12))
+#  define MAJOR(dev)	(((dev) & 0xfff00) >> 8)
+#  define MINOR(dev)	(((dev) & 0xff) | (((dev) >> 12) & 0xfff00))
+#  define MKDEV(ma,mi)	(((mi) & 0xff) | ((ma) << 8) | (((mi) & ~0xff) << 12))
 #else
 #  define MAJOR(x) major((x))
 #  define MINOR(x) minor((x))
diff --git a/lib/format_text/archiver.c b/lib/format_text/archiver.c
index 1bc9557..e52854f 100644
--- a/lib/format_text/archiver.c
+++ b/lib/format_text/archiver.c
@@ -364,7 +364,7 @@ int backup_restore_vg(struct cmd_context *cmd, struct volume_group *vg,
 	struct dm_list new_pvs;
 	struct pv_list *pvl, *new_pvl;
 	struct physical_volume *existing_pv, *pv;
-	struct dm_list *pvs = &vg->pvs;;
+	struct dm_list *pvs = &vg->pvs;
 	struct format_instance *fid;
 	struct format_instance_ctx fic;
 	int should_write_pv;
diff --git a/lib/log/log.c b/lib/log/log.c
index 30c9c59..d939b9d 100644
--- a/lib/log/log.c
+++ b/lib/log/log.c
@@ -452,7 +452,7 @@ void print_log(int level, const char *file, int line, int dm_errno_or_class,
 			goto done;
 
 		bufused += n;
-		if (n >= sizeof(buf))
+		if (n >= (int) sizeof(buf))
 			bufused = sizeof(buf) - 1;
 	      done:
 		buf[bufused] = '\n';
diff --git a/lib/metadata/lv_manip.c b/lib/metadata/lv_manip.c
index d99d347..5e4a81f 100644
--- a/lib/metadata/lv_manip.c
+++ b/lib/metadata/lv_manip.c
@@ -1662,8 +1662,10 @@ static int _setup_alloced_segment(struct logical_volume *lv, uint64_t status,
 	lv->size += (uint64_t) extents * lv->vg->extent_size;
 
 	if (lv_is_thin_pool_data(lv)) {
+		if (!(thin_pool_seg = get_only_segment_using_this_lv(lv)))
+			return_0;
+
 		/* Update thin pool segment from the layered LV */
-		thin_pool_seg = get_only_segment_using_this_lv(lv);
 		thin_pool_seg->lv->le_count =
 			thin_pool_seg->len =
 			thin_pool_seg->area_len = lv->le_count;
@@ -6201,7 +6203,7 @@ int remove_layer_from_lv(struct logical_volume *lv,
 	struct lv_segment *parent_seg;
 	struct segment_type *segtype;
 	struct lv_names lv_names;
-	int r;
+	unsigned r;
 
 	log_very_verbose("Removing layer %s for %s", layer_lv->name, lv->name);
 
@@ -6277,7 +6279,7 @@ struct logical_volume *insert_layer_for_lv(struct cmd_context *cmd,
 	struct segment_type *segtype;
 	struct lv_segment *mapseg;
 	struct lv_names lv_names;
-	unsigned exclusive = 0;
+	unsigned exclusive = 0, i;
 
 	/* create an empty layer LV */
 	if (dm_snprintf(name, sizeof(name), "%s%s", lv_where->name, layer_suffix) < 0) {
@@ -6370,8 +6372,8 @@ struct logical_volume *insert_layer_for_lv(struct cmd_context *cmd,
 	 *   currently supported only for thin data layer
 	 *   FIXME: without strcmp it breaks mirrors....
 	 */
-	for (r = 0; r < DM_ARRAY_SIZE(_suffixes); ++r)
-		if (strcmp(layer_suffix, _suffixes[r]) == 0) {
+	for (i = 0; i < DM_ARRAY_SIZE(_suffixes); ++i)
+		if (strcmp(layer_suffix, _suffixes[i]) == 0) {
 			lv_names.old = lv_where->name;
 			lv_names.new = layer_lv->name;
 			if (!for_each_sub_lv(layer_lv, _rename_cb, (void *) &lv_names))
diff --git a/lib/metadata/metadata.c b/lib/metadata/metadata.c
index 8478abb..a41c227 100644
--- a/lib/metadata/metadata.c
+++ b/lib/metadata/metadata.c
@@ -2572,7 +2572,7 @@ static int _lv_validate_references_single(struct logical_volume *lv, void *data)
  */
 static int _validate_lock_args_chars(const char *lock_args)
 {
-	int i;
+	unsigned i;
 	char c;
 	int found_colon = 0;
 	int r = 1;
@@ -2581,13 +2581,13 @@ static int _validate_lock_args_chars(const char *lock_args)
 		c = lock_args[i];
 
 		if (!isalnum(c) && c != '.' && c != '_' && c != '-' && c != '+' && c != ':') {
-			log_error(INTERNAL_ERROR "Invalid character at index %d of lock_args \"%s\"",
+			log_error(INTERNAL_ERROR "Invalid character at index %u of lock_args \"%s\"",
 				  i, lock_args);
 			r = 0;
 		}
 
 		if (c == ':' && found_colon) {
-			log_error(INTERNAL_ERROR "Invalid colon at index %d of lock_args \"%s\"",
+			log_error(INTERNAL_ERROR "Invalid colon at index %u of lock_args \"%s\"",
 				  i, lock_args);
 			r = 0;
 		}
diff --git a/lib/metadata/pv_manip.c b/lib/metadata/pv_manip.c
index 8c3a5dd..4a0992b 100644
--- a/lib/metadata/pv_manip.c
+++ b/lib/metadata/pv_manip.c
@@ -695,8 +695,6 @@ static int pvremove_check(struct cmd_context *cmd, const char *name,
 			  unsigned force_count, unsigned prompt, struct dm_list *pvslist)
 {
 	static const char really_wipe_msg[] = "Really WIPE LABELS from physical volume";
-	static const char not_removed_msg[] = "physical volume label not removed";
-	static const char pvremove_force_hint_msg[] = "(If you are certain you need pvremove, then confirm by using --force twice.)";
 	struct device *dev;
 	struct label *label;
 	struct pv_list *pvl;
@@ -707,7 +705,7 @@ static int pvremove_check(struct cmd_context *cmd, const char *name,
 	/* FIXME Check partition type is LVM unless --force is given */
 
 	if (!(dev = dev_cache_get(name, cmd->filter))) {
-		log_error("Device %s not found", name);
+		log_error("Device %s not found.", name);
 		return 0;
 	}
 
@@ -725,8 +723,8 @@ static int pvremove_check(struct cmd_context *cmd, const char *name,
 			pv = pvl->pv;
 
 	if (!pv) {
-		log_error(INTERNAL_ERROR "Physical Volume %s has a label,"
-			  " but is neither in a VG nor orphan.", name);
+		log_error(INTERNAL_ERROR "Physical Volume %s has a label, "
+			  "but is neither in a VG nor orphan.", name);
 		goto out; /* better safe than sorry */
 	}
 
@@ -734,49 +732,47 @@ static int pvremove_check(struct cmd_context *cmd, const char *name,
 		if ((used = is_used_pv(pv)) < 0)
 			goto_out;
 
-		if (used && force_count < 2) {
-			log_error("PV '%s' is marked as belonging to a VG "
-				  "but its metadata is missing.", name);
-			log_error("%s", pvremove_force_hint_msg);
-			goto out;
+		if (used) {
+			log_warn("WARNING: PV '%s' is marked as belonging to a VG "
+				 "but its metadata is missing.", name);
+
+			if (force_count < 2)
+				goto_bad;
+
+			if (!prompt &&
+			    yes_no_prompt("%s \"%s\" that is marked as belonging to a VG [y/n]? ",
+					  really_wipe_msg, name) == 'n')
+				goto_bad;
 		}
 	} else {
-		/* we must have -ff to overwrite a non orphan */
-		if (force_count < 2) {
-			log_error("PV %s belongs to Volume Group %s so please use vgreduce first.", name, pv_vg_name(pv));
-			log_error("%s", pvremove_force_hint_msg);
-			goto out;
-		}
-	}
+		log_warn("WARNING: PV %s belongs to Volume Group %s "
+			 "(consider using vgreduce).", name, pv_vg_name(pv));
 
-	/* prompt */
-	if (!prompt) {
-		if (is_orphan(pv)) {
-			if (used) {
-				if (yes_no_prompt("%s \"%s\" that is marked as belonging to a VG [y/n]? ",
-						   really_wipe_msg, name) == 'n') {
-					log_error("%s: %s", name, not_removed_msg);
-					goto out;
-				}
-			}
-		} else {
-			if (yes_no_prompt("%s \"%s\" of volume group \"%s\" [y/n]? ",
-					  really_wipe_msg, name, pv_vg_name(pv)) == 'n') {
-				log_error("%s: %s", name, not_removed_msg);
-				goto out;
-			}
-		}
+		if (force_count < 2)
+			goto_bad;
+
+		if (!prompt &&
+		    yes_no_prompt("%s \"%s\" of volume group \"%s\" [y/n]? ",
+				  really_wipe_msg, name, pv_vg_name(pv)) == 'n')
+			goto_bad;
 	}
 
-	if (force_count) {
+	if (force_count)
 		log_warn("WARNING: Wiping physical volume label from "
 			  "%s%s%s%s", name,
 			  !is_orphan(pv) ? " of volume group \"" : "",
 			  pv_vg_name(pv),
 			  !is_orphan(pv) ? "\"" : "");
-	}
 
 	r = 1;
+bad:
+	if (!r) {
+		log_error("%s: physical volume label not removed.", name);
+
+		if (force_count < 2) /* Show hint as log_error() */
+			log_error("(If you are certain you need pvremove, "
+				  "then confirm by using --force twice.)");
+	}
 out:
 	return r;
 }
diff --git a/lib/metadata/raid_manip.c b/lib/metadata/raid_manip.c
index 0fec123..e6684fc 100644
--- a/lib/metadata/raid_manip.c
+++ b/lib/metadata/raid_manip.c
@@ -864,7 +864,7 @@ static int _raid_extract_images(struct logical_volume *lv, uint32_t new_count,
 	log_verbose("Extracting %u %s from %s/%s", extract,
 		    (extract > 1) ? "images" : "image",
 		    lv->vg->name, lv->name);
-	if (dm_list_size(target_pvs) < extract) {
+	if ((int) dm_list_size(target_pvs) < extract) {
 		log_error("Unable to remove %d images:  Only %d device%s given.",
 			  extract, dm_list_size(target_pvs),
 			  (dm_list_size(target_pvs) == 1) ? "" : "s");
diff --git a/lib/metadata/thin_manip.c b/lib/metadata/thin_manip.c
index de3c7e8..aa5f388 100644
--- a/lib/metadata/thin_manip.c
+++ b/lib/metadata/thin_manip.c
@@ -320,9 +320,9 @@ int pool_check_overprovisioning(const struct logical_volume *lv)
 		 * for growing - threshold is 100% or percent is 0% */
 		sz = poolsum;
 	else
-		sz = ~0; /* No warning */
+		sz = UINT64_C(~0); /* No warning */
 
-	if (sz != ~0) {
+	if (sz != UINT64_C(~0)) {
 		log_warn("WARNING: Sum of all thin volume sizes (%s) exceeds the "
 			 "size of thin pool%s%s%s (%s)!",
 			 display_size(cmd, thinsum),
diff --git a/lib/misc/sharedlib.c b/lib/misc/sharedlib.c
index 28b8aae..db1ba43 100644
--- a/lib/misc/sharedlib.c
+++ b/lib/misc/sharedlib.c
@@ -27,10 +27,13 @@ void get_shared_library_path(struct cmd_context *cmd, const char *libname,
 {
 	struct stat info;
 
+	if (!path_len)
+		return;
+
 	/* If libname doesn't begin with '/' then use lib_dir/libname,
 	 * if present */
 	if (libname[0] == '/' ||
-            (!cmd->lib_dir &&
+	    (!cmd->lib_dir &&
 	     !(cmd->lib_dir = find_config_tree_str(cmd, global_library_dir_CFG, NULL))) ||
 	    (dm_snprintf(path, path_len, "%s/%s", cmd->lib_dir,
 			 libname) == -1) || stat(path, &info) == -1) {
diff --git a/lib/raid/raid.c b/lib/raid/raid.c
index 56eae1c..36f455d 100644
--- a/lib/raid/raid.c
+++ b/lib/raid/raid.c
@@ -121,7 +121,7 @@ static int _raid_text_import(struct lv_segment *seg,
 		{ "min_recovery_rate",	&seg->min_recovery_rate },
 		{ "max_recovery_rate",	&seg->max_recovery_rate },
 	}, *aip = raid_attr_import;
-	int i;
+	unsigned i;
 
 	for (i = 0; i < DM_ARRAY_SIZE(raid_attr_import); i++, aip++) {
 		if (dm_config_has_node(sn, aip->name)) {
diff --git a/lib/report/report.c b/lib/report/report.c
index ed6202c..bd7c163 100644
--- a/lib/report/report.c
+++ b/lib/report/report.c
@@ -1446,7 +1446,8 @@ static int _do_get_kernel_cache_settings_list(struct dm_pool *mem,
 		buf_len = strlen(key) + strlen(value) + 2;
 		if (!(buf = dm_pool_alloc(mem, buf_len)))
 			return_0;
-		dm_snprintf(buf, buf_len, "%s=%s", key, value);
+		if (dm_snprintf(buf, buf_len, "%s=%s", key, value) < 0)
+			return_0;
 		if (!str_list_add_no_dup_check(mem, result, buf))
 			return_0;
 	}
diff --git a/libdaemon/client/daemon-io.c b/libdaemon/client/daemon-io.c
index f072764..5419d40 100644
--- a/libdaemon/client/daemon-io.c
+++ b/libdaemon/client/daemon-io.c
@@ -49,8 +49,9 @@ int buffer_read(int fd, struct buffer *buffer) {
 		} else if (result == 0) {
 			errno = ECONNRESET;
 			return 0; /* we should never encounter EOF here */
-		} else if (result < 0 && ( errno == EAGAIN || errno == EWOULDBLOCK ||
-					   errno == EINTR || errno == EIO)) {
+		} else if (result < 0 && (errno == EAGAIN ||
+					  (EWOULDBLOCK != EAGAIN && errno == EWOULDBLOCK) ||
+					  errno == EINTR || errno == EIO)) {
 			fd_set in;
 			FD_ZERO(&in);
 			FD_SET(fd, &in);
@@ -78,8 +79,9 @@ int buffer_write(int fd, const struct buffer *buffer) {
 			result = write(fd, use->mem + written, use->used - written);
 			if (result > 0)
 				written += result;
-			else if (result < 0 && ( errno == EAGAIN || errno == EWOULDBLOCK ||
-						 errno == EINTR || errno == EIO)) {
+			else if (result < 0 && (errno == EAGAIN ||
+						(EWOULDBLOCK != EAGAIN && errno == EWOULDBLOCK) ||
+						errno == EINTR || errno == EIO)) {
 				fd_set out;
 				FD_ZERO(&out);
 				FD_SET(fd, &out);
diff --git a/libdm/libdm-report.c b/libdm/libdm-report.c
index 55b5ff0..8250a35 100644
--- a/libdm/libdm-report.c
+++ b/libdm/libdm-report.c
@@ -839,8 +839,9 @@ static int _get_canonical_field_name(const char *field,
 			diff = 1;
 			continue;
 		}
-		if (i >= fcanonical_len) {
-			log_error("%s: field name too long", field);
+		if ((i + 1) >= fcanonical_len) {
+			canonical_field[0] = '\0';
+			log_error("%s: field name too long.", field);
 			return 0;
 		}
 		canonical_field[i++] = *field;
@@ -888,7 +889,7 @@ static void _all_match_combine(const struct dm_report_object_type *types,
 	const struct dm_report_object_type *t;
 	size_t prefix_len;
 
-	if (!_get_canonical_field_name(field, flen, field_canon, DM_REPORT_FIELD_TYPE_ID_LEN, NULL))
+	if (!_get_canonical_field_name(field, flen, field_canon, sizeof(field_canon), NULL))
 		return;
 	flen = strlen(field_canon);
 
@@ -948,7 +949,7 @@ static int _get_field(struct dm_report *rh, const char *field, size_t flen,
 	if (!flen)
 		return 0;
 
-	if (!_get_canonical_field_name(field, flen, field_canon, DM_REPORT_FIELD_TYPE_ID_LEN, NULL))
+	if (!_get_canonical_field_name(field, flen, field_canon, sizeof(field_canon), NULL))
 		return_0;
 
 	for (f = 0; _implicit_report_fields[f].report_fn; f++) {
@@ -1062,7 +1063,7 @@ static int _key_match(struct dm_report *rh, const char *key, size_t len,
 		return 0;
 	}
 
-	if (!_get_canonical_field_name(key, len, key_canon, DM_REPORT_FIELD_TYPE_ID_LEN, NULL))
+	if (!_get_canonical_field_name(key, len, key_canon, sizeof(key_canon), NULL))
 		return_0;
 
 	for (f = 0; _implicit_report_fields[f].report_fn; f++)
@@ -1195,7 +1196,7 @@ static int _canonicalize_field_ids(struct dm_report *rh)
 
 	for (i = 0; i < registered_field_count; i++) {
 		if (!_get_canonical_field_name(rh->fields[i].id, strlen(rh->fields[i].id),
-					       canonical_field, DM_REPORT_FIELD_TYPE_ID_LEN, &differs))
+					       canonical_field, sizeof(canonical_field), &differs))
 			return_0;
 
 		if (differs) {
diff --git a/libdm/libdm-stats.c b/libdm/libdm-stats.c
index 0c1fe7a..82d3fa5 100644
--- a/libdm/libdm-stats.c
+++ b/libdm/libdm-stats.c
@@ -453,7 +453,7 @@ static int _stats_parse_histogram_spec(struct dm_stats *dms,
 				       struct dm_stats_region *region,
 				       const char *histogram)
 {
-	static const char *_valid_chars = "0123456789,";
+	static const char _valid_chars[] = "0123456789,";
 	uint64_t scale = region->timescale, this_val = 0;
 	struct dm_pool *mem = dms->hist_mem;
 	struct dm_histogram_bin cur;
@@ -740,9 +740,11 @@ static int _stats_parse_histogram(struct dm_pool *mem, char *hist_str,
 				  struct dm_histogram **histogram,
 				  struct dm_stats_region *region)
 {
-	struct dm_histogram hist, *bounds = region->bounds;
-	static const char *_valid_chars = "0123456789:";
-	int nr_bins = region->bounds->nr_bins;
+	static const char _valid_chars[] = "0123456789:";
+	struct dm_histogram *bounds = region->bounds;
+	struct dm_histogram hist = {
+		.nr_bins = region->bounds->nr_bins
+	};
 	const char *c, *v, *val_start;
 	struct dm_histogram_bin cur;
 	uint64_t sum = 0, this_val;
@@ -754,8 +756,6 @@ static int _stats_parse_histogram(struct dm_pool *mem, char *hist_str,
 	if (!dm_pool_begin_object(mem, sizeof(cur)))
 		return_0;
 
-	hist.nr_bins = nr_bins;
-
 	if (!dm_pool_grow_object(mem, &hist, sizeof(hist)))
 		goto_bad;
 
@@ -800,7 +800,7 @@ static int _stats_parse_histogram(struct dm_pool *mem, char *hist_str,
 		}
 	} while (*c && (*c != '\n'));
 
-	log_debug("Added region histogram data with %d entries.", nr_bins);
+	log_debug("Added region histogram data with %d entries.", hist.nr_bins);
 
 	*histogram = dm_pool_end_object(mem);
 	(*histogram)->sum = sum;
@@ -963,7 +963,9 @@ static void _stats_walk_next(const struct dm_stats *dms, int region,
 	if (!dms || !dms->regions)
 		return;
 
-	cur = &dms->regions[*cur_r];
+	if (!(cur = &dms->regions[*cur_r]))
+		return;
+
 	present = _stats_region_present(cur);
 
 	if (region && present)
@@ -1314,7 +1316,7 @@ static int _dm_stats_populate_region(struct dm_stats *dms, uint64_t region_id,
 	if (!_stats_bound(dms))
 		return_0;
 
-	if (!_stats_parse_region(dms, resp, region, region->timescale)) {
+	if (!region || !_stats_parse_region(dms, resp, region, region->timescale)) {
 		log_error("Could not parse @stats_print message response.");
 		return 0;
 	}
@@ -1998,7 +2000,7 @@ static struct dm_histogram *_alloc_dm_histogram(int nr_bins)
  */
 struct dm_histogram *dm_histogram_bounds_from_string(const char *bounds_str)
 {
-	static const char *_valid_chars = "0123456789,muns";
+	static const char _valid_chars[] = "0123456789,muns";
 	uint64_t this_val = 0, mult = 1;
 	const char *c, *v, *val_start;
 	struct dm_histogram_bin *cur;
diff --git a/libdm/mm/pool-fast.c b/libdm/mm/pool-fast.c
index e7fedfc..65ca856 100644
--- a/libdm/mm/pool-fast.c
+++ b/libdm/mm/pool-fast.c
@@ -100,7 +100,7 @@ void *dm_pool_alloc_aligned(struct dm_pool *p, size_t s, unsigned alignment)
 		_align_chunk(c, alignment);
 
 	/* have we got room ? */
-	if (!c || (c->begin > c->end) || (c->end - c->begin < s)) {
+	if (!c || (c->begin > c->end) || ((c->end - c->begin) < (int) s)) {
 		/* allocate new chunk */
 		size_t needed = s + alignment + sizeof(struct chunk);
 		c = _new_chunk(p, (needed > p->chunk_size) ?
@@ -177,7 +177,7 @@ int dm_pool_begin_object(struct dm_pool *p, size_t hint)
 	if (c)
 		_align_chunk(c, align);
 
-	if (!c || (c->begin > c->end) || (c->end - c->begin < hint)) {
+	if (!c || (c->begin > c->end) || ((c->end - c->begin) < (int) hint)) {
 		/* allocate a new chunk */
 		c = _new_chunk(p,
 			       hint > (p->chunk_size - sizeof(struct chunk)) ?
@@ -200,7 +200,7 @@ int dm_pool_grow_object(struct dm_pool *p, const void *extra, size_t delta)
 	if (!delta)
 		delta = strlen(extra);
 
-	if (c->end - (c->begin + p->object_len) < delta) {
+	if ((c->end - (c->begin + p->object_len)) < (int) delta) {
 		/* move into a new chunk */
 		if (p->object_len + delta > (p->chunk_size / 2))
 			nc = _new_chunk(p, (p->object_len + delta) * 2);
diff --git a/test/lib/aux.sh b/test/lib/aux.sh
index 6250143..12316aa 100644
--- a/test/lib/aux.sh
+++ b/test/lib/aux.sh
@@ -1007,6 +1007,18 @@ raid456_replace_works() {
 	esac
 }
 
+#
+# Some 32bit kernel cannot pass some erroring magic which forces
+# thin-pool to be falling into Error state.
+#
+# Skip test on such kernels (see: https://bugzilla.redhat.com/1310661)
+#
+thin_pool_error_works_32() {
+	case "$(uname -r)" in
+	  2.6.32-618.*.i686) return 1 ;;
+	esac
+}
+
 udev_wait() {
 	pgrep udev >/dev/null || return 0
 	which udevadm &>/dev/null || return 0
diff --git a/test/shell/pvremove-usage.sh b/test/shell/pvremove-usage.sh
index 94c606b..08c8b24 100644
--- a/test/shell/pvremove-usage.sh
+++ b/test/shell/pvremove-usage.sh
@@ -54,14 +54,17 @@ for mdacp in 0 1 2; do
     vgcreate $vg "$dev1" "$dev2"
 
     # pvremove -f fails when pv in a vg (---metadatacopies $mdacp)
-    not pvremove -f "$dev1"
+    not pvremove -f "$dev1" 2>&1 | tee out
+    grep "belongs" out
     pvs "$dev1"
 
     # pvremove -ff fails without confirmation when pv in a vg (---metadatacopies $mdacp)
-    echo n | not pvremove -ff "$dev1"
+    not pvremove -ff "$dev1" 2>&1 | tee out
+    grep "belongs" out
 
     # pvremove -ff succeds with confirmation when pv in a vg (---metadatacopies $mdacp)
-    pvremove -ffy "$dev1"
+    pvremove -ffy "$dev1" 2>&1 | tee out
+    grep "belongs" out
     not pvs "$dev1"
 
     vgreduce --removemissing $vg
diff --git a/test/shell/thin-flags.sh b/test/shell/thin-flags.sh
index 7dd0d6e..95eafa0 100644
--- a/test/shell/thin-flags.sh
+++ b/test/shell/thin-flags.sh
@@ -39,6 +39,7 @@ fake_metadata_() {
 # Main
 #
 aux have_thin 1 3 0 || skip
+aux thin_pool_error_works_32 || skip
 
 aux prepare_vg 2 256
 
diff --git a/tools/dmsetup.c b/tools/dmsetup.c
index 4db6004..b61b42f 100644
--- a/tools/dmsetup.c
+++ b/tools/dmsetup.c
@@ -4384,7 +4384,7 @@ static int _report_init(const struct command *cmd, const char *subcommand)
 				selection, NULL, NULL)))
 		goto_out;
 
-	if ((_report_type & DR_TREE) && !_build_whole_deptree(cmd)) {
+	if ((_report_type & DR_TREE) && cmd && !_build_whole_deptree(cmd)) {
 		err("Internal device dependency tree creation failed.");
 		goto out;
 	}
diff --git a/tools/lvchange.c b/tools/lvchange.c
index 91c8728..316a786 100644
--- a/tools/lvchange.c
+++ b/tools/lvchange.c
@@ -789,7 +789,7 @@ static int _lvchange_writemostly(struct logical_volume *lv)
 				return 0;
 			}
 
-			for (s = 0; s < raid_seg->area_count; s++) {
+			for (s = 0; s < (int) raid_seg->area_count; s++) {
 				/*
 				 * We don't bother checking the metadata area,
 				 * since writemostly only affects the data areas.
diff --git a/tools/lvconvert.c b/tools/lvconvert.c
index 4e6d91b..e7394c0 100644
--- a/tools/lvconvert.c
+++ b/tools/lvconvert.c
@@ -90,7 +90,7 @@ struct convert_poll_id_list {
 
 static int _lvconvert_validate_names(struct lvconvert_params *lp)
 {
-	int i, j;
+	unsigned i, j;
 	const char *names[] = {
 		(lp->lv_name == lp->pool_data_name) ? NULL : lp->lv_name, "converted",
 		lp->pool_data_name, "pool",
diff --git a/tools/lvrename.c b/tools/lvrename.c
index 1f6e829..e37d8aa 100644
--- a/tools/lvrename.c
+++ b/tools/lvrename.c
@@ -81,7 +81,7 @@ int lvrename(struct cmd_context *cmd, int argc, char **argv)
 	char *lv_name_old, *lv_name_new;
 	const char *vg_name, *vg_name_new, *vg_name_old;
 	char *st;
-	int ret = ECMD_FAILED;
+	int ret;
 
 	if (argc == 3) {
 		vg_name = skip_dev_dir(cmd, argv[0], NULL);
@@ -169,6 +169,6 @@ int lvrename(struct cmd_context *cmd, int argc, char **argv)
 			      _lvrename_single);
 
 	destroy_processing_handle(cmd, handle);
-	return ret;
 
+	return ret;
 }
diff --git a/tools/lvresize.c b/tools/lvresize.c
index af6ce07..2c2df36 100644
--- a/tools/lvresize.c
+++ b/tools/lvresize.c
@@ -199,10 +199,12 @@ int lvresize(struct cmd_context *cmd, int argc, char **argv)
 {
 	struct processing_handle *handle;
 	struct lvresize_params lp = { 0 };
-	int ret = ECMD_FAILED;
+	int ret;
 
-	if (!_lvresize_params(cmd, argc, argv, &lp))
+	if (!_lvresize_params(cmd, argc, argv, &lp)) {
+		stack;
 		return EINVALID_CMD_LINE;
+	}
 
 	if (!(handle = init_processing_handle(cmd))) {
 		log_error("Failed to initialize processing handle.");
diff --git a/tools/vgrename.c b/tools/vgrename.c
index 633999e..e5af820 100644
--- a/tools/vgrename.c
+++ b/tools/vgrename.c
@@ -38,7 +38,6 @@ static int _vgrename_single(struct cmd_context *cmd, const char *vg_name,
 			    struct volume_group *vg, struct processing_handle *handle)
 {
 	struct vgrename_params *vp = (struct vgrename_params *) handle->custom_handle;
-	struct lvmcache_vginfo *vginfo;
 	char old_path[NAME_LEN];
 	char new_path[NAME_LEN];
 	struct id id;
@@ -72,7 +71,7 @@ static int _vgrename_single(struct cmd_context *cmd, const char *vg_name,
 	 */
 	lvmcache_seed_infos_from_lvmetad(cmd);
 
-	if ((vginfo = lvmcache_vginfo_from_vgname(vp->vg_name_new, NULL))) {
+	if (lvmcache_vginfo_from_vgname(vp->vg_name_new, NULL)) {
 		log_error("New VG name \"%s\" already exists", vp->vg_name_new);
 		return ECMD_FAILED;
 	}
