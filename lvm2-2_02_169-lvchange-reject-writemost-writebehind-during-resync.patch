 WHATS_NEW                                |  1 +
 lib/metadata/metadata-exported.h         |  1 +
 lib/metadata/raid_manip.c                |  8 ++++++-
 test/shell/lvchange-raid1-writemostly.sh | 41 ++++++++++++++++++++++++++++++++
 tools/lvchange.c                         | 15 ++++++++++++
 5 files changed, 65 insertions(+), 1 deletion(-)

diff --git a/WHATS_NEW b/WHATS_NEW
index 7a32770..f561f3d 100644
--- a/WHATS_NEW
+++ b/WHATS_NEW
@@ -1,5 +1,6 @@
 Version 2.02.169 - 
 =================================
+  Reject writemostly/writebehind in lvchange during resynchronization.
   Fix handling of transient failure of a PV holding RAID sub LVs.
 
 Version 2.02.167 - 
diff --git a/lib/metadata/metadata-exported.h b/lib/metadata/metadata-exported.h
index f6c3bf5..843f8d9 100644
--- a/lib/metadata/metadata-exported.h
+++ b/lib/metadata/metadata-exported.h
@@ -1144,6 +1144,7 @@ int lv_raid_replace(struct logical_volume *lv, int force,
 		    struct dm_list *remove_pvs, struct dm_list *allocate_pvs);
 int lv_raid_remove_missing(struct logical_volume *lv);
 int partial_raid_lv_supports_degraded_activation(const struct logical_volume *lv);
+int lv_raid_in_sync(const struct logical_volume *lv);
 /* --  metadata/raid_manip.c */
 
 /* ++  metadata/cache_manip.c */
diff --git a/lib/metadata/raid_manip.c b/lib/metadata/raid_manip.c
index 27e246f..0a1c867 100644
--- a/lib/metadata/raid_manip.c
+++ b/lib/metadata/raid_manip.c
@@ -85,7 +85,7 @@ static int _activate_sublv_preserving_excl(struct logical_volume *top_lv,
  * Returns: 1 if in-sync, 0 otherwise.
  */
 #define _RAID_IN_SYNC_RETRIES  6
-static int _raid_in_sync(struct logical_volume *lv)
+static int _raid_in_sync(const struct logical_volume *lv)
 {
 	int retries = _RAID_IN_SYNC_RETRIES;
 	dm_percent_t sync_percent;
@@ -116,6 +116,12 @@ static int _raid_in_sync(struct logical_volume *lv)
 	return (sync_percent == DM_PERCENT_100) ? 1 : 0;
 }
 
+/* External interface to raid in-sync check */
+int lv_raid_in_sync(const struct logical_volume *lv)
+{
+	return _raid_in_sync(lv);
+}
+
 /* Check if RaidLV @lv is synced or any raid legs of @lv are not synced */
 static int _raid_devs_sync_healthy(struct logical_volume *lv)
 {
diff --git a/test/shell/lvchange-raid1-writemostly.sh b/test/shell/lvchange-raid1-writemostly.sh
new file mode 100644
index 0000000..edf11bd
--- /dev/null
+++ b/test/shell/lvchange-raid1-writemostly.sh
@@ -0,0 +1,41 @@
+#!/bin/sh
+# Copyright (C) 2017 Red Hat, Inc. All rights reserved.
+#
+# This copyrighted material is made available to anyone wishing to use,
+# modify, copy, or redistribute it subject to the terms and conditions
+# of the GNU General Public License v.2.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin Street, Fifth Floor, Boston, MA2110-1301 USA
+
+SKIP_WITH_LVMLOCKD=1
+SKIP_WITH_LVMPOLLD=1
+
+. lib/inittest
+
+which mkfs.ext4 || skip
+aux have_raid 1 3 5 || skip
+
+aux prepare_vg 4
+
+for d in $dev1 $dev2 $dev3 $dev4
+do
+	aux delay_dev $d 1
+done
+
+#
+# Test writemostly prohibited on resyncrhonizing raid1
+#
+
+# Create 4-way striped LV
+lvcreate -aey --ty raid1 -m 3 -L 32M -n $lv1 $vg
+not lvchange -y --writemostly $dev1 $vg/$lv1
+check lv_field $vg/$lv1 segtype "raid1"
+check lv_field $vg/$lv1 stripes 4
+check lv_attr_bit health $vg/${lv1}_rimage_0 "-"
+aux wait_for_sync $vg $lv1
+lvchange -y --writemostly $dev1 $vg/$lv1
+check lv_attr_bit health $vg/${lv1}_rimage_0 "w"
+
+vgremove -ff $vg
diff --git a/tools/lvchange.c b/tools/lvchange.c
index 3e4ae12..a1c60e9 100644
--- a/tools/lvchange.c
+++ b/tools/lvchange.c
@@ -737,6 +737,21 @@ static int _lvchange_writemostly(struct logical_volume *lv)
 		return 0;
 	}
 
+	/*
+	 * Prohibit writebehind and writebehind during synchronization.
+	 *
+	 * FIXME: we can do better once we can distingush between
+	 *        an initial sync after a linear -> raid1 upconversion
+	 *        and any later additions of legs, requested resyncs
+	 *        via lvchange or leg repairs/replacements.
+	 */
+	if (!lv_raid_in_sync(lv)) {
+		log_error("Unable to change write%s on %s while it is not in-sync.",
+			  arg_is_set(cmd, writemostly_ARG) ? "mostly" : "behind",
+			  display_lvname(lv));
+		return 0;
+	}
+
 	if (arg_count(cmd, writebehind_ARG))
 		raid_seg->writebehind = arg_uint_value(cmd, writebehind_ARG, 0);
 
